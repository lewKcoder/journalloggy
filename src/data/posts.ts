import type { Post } from "../types/post";

export const MOCK_POSTS: Post[] = [
  // {
  //   id: "1",
  //   projectId: "color-lab",
  //   date: "2026-01-22",
  //   category: "Engineering",
  //   title: "1 vCPU Linux runner now generally available in GitHub Actions",
  //   excerpt:
  //     "GitHub Actionsにおいて、より軽量なワークロードに向けた1 vCPUランナーが利用可能になりました。コスト効率とパフォーマンスのバランスについて考察します。",
  //   content: `
  //     <p>ソフトウェア開発の自動化において、リソースの最適化は常に重要な課題です。多くの単純なビルドやテストのワークフローでは、標準的な2 vCPUのマシンはオーバースペックであることが多いのが現実でした。</p>
  //     <h2>制約がもたらす最適化</h2>
  //     <p>1 vCPUという制約は、一見不便に見えるかもしれませんが、適切なワークロード（Lint、静的解析、シンプルなデプロイなど）においては、消費クレジットを劇的に抑える強力な選択肢となります。</p>
  //     <blockquote class="border-l-2 border-neutral-300 dark:border-neutral-700 pl-6 my-10 italic text-neutral-500">
  //       「優れたデザインとは、これ以上加えるものがないときではなく、これ以上取り除くものがないときに達成される。」
  //     </blockquote>
  //     <p>このアップデートは、GitHubが開発者の多様なニーズに応えようとしている姿勢の現れと言えるでしょう。</p>
  //   `,
  // },
  // {
  //   id: "2",
  //   projectId: "typerim",
  //   date: "2025-12-10",
  //   category: "Thought",
  //   title: "A Complete Guide to useEffect (Revisited)",
  //   excerpt:
  //     "ReactのuseEffectフックが持つ「同期」というメンタルモデルについて。なぜ我々は依存配列に苦しむのか。",
  //   content: `
  //     <p>useEffectの本質は、レンダー結果を外部システムと同期させることにあります。多くの開発者がuseEffectを「副作用を実行する場所」として理解していますが、より正確には「Reactの世界と外部の世界を同期させるための仕組み」です。</p>
  //     <h2>依存配列の本当の意味</h2>
  //     <p>依存配列は「このエフェクトがいつ再実行されるべきか」を宣言するものではありません。それは「このエフェクトが同期に使用するすべての値」のリストです。この微妙な違いを理解することで、多くの混乱が解消されます。</p>
  //     <p>エフェクトの中で使用するすべてのリアクティブな値は、依存配列に含めなければなりません。これはルールではなく、正しさの定義そのものです。</p>
  //   `,
  // },
  // {
  //   id: "3",
  //   projectId: "front-template",
  //   date: "2025-11-30",
  //   category: "Design",
  //   title: "The Silent Language of Typography",
  //   excerpt:
  //     "文字の太さ、余白、そして行間。言葉そのもの以上に多くを語るタイポグラフィの力について。",
  //   content: `
  //     <p>良いデザインは目立たず、しかし確実に体験の質を向上させます。タイポグラフィはその最たる例です。私たちは普段、文字の形や配置を意識することなく文章を読みますが、それこそがタイポグラフィが正しく機能している証拠なのです。</p>
  //     <h2>ウェイトが語るもの</h2>
  //     <p>フォントウェイトは視覚的な階層を作り出します。見出しに使う太い文字は「ここから始まる」というシグナルを送り、本文の標準的なウェイトは「ここを読み進めてください」と穏やかに誘導します。</p>
  //     <p>余白もまた、沈黙の中で語りかけます。適切なホワイトスペースは、読者に呼吸する余裕を与え、情報の塊を消化しやすくします。</p>
  //   `,
  // },
  {
    id: "4",
    projectId: "prism",
    date: "2026-02-05",
    category: "Engineering",
    title: "Workflow Matrix Strategy for Cost-Effective CI",
    excerpt:
      "マトリクス戦略を活用してCI/CDのコストを最大40%削減する方法。並列実行とリソース配分の最適解を探る。",
    content: `
      <p>CI/CDパイプラインのコスト最適化において、マトリクス戦略は強力なツールです。しかし、単に並列化するだけではコストが増大するリスクもあります。</p>
      <h2>最適なマトリクス設計</h2>
      <p>重要なのは、各ジョブの実行時間とリソース要件を正確に把握し、適切な粒度でマトリクスを分割することです。テストスイートを論理的なグループに分け、それぞれに最適なランナーサイズを割り当てることで、全体のコストを大幅に削減できます。</p>
      <p>特に、依存関係のないジョブを並列実行し、依存関係のあるジョブを直列に配置することで、待ち時間を最小化しながらリソースの無駄遣いを防ぐことができます。</p>
    `,
  },
  {
    id: "5",
    projectId: "oshi",
    date: "2025-11-15",
    category: "Thought",
    title: "Custom Hooks: 抽象化の適切な粒度",
    excerpt:
      "カスタムフックをいつ作るべきか。早すぎる抽象化の罠と、コードの再利用性について。",
    content: `
      <p>カスタムフックはReactの強力な機能ですが、すべてのロジックをカスタムフックに抽出すべきというわけではありません。適切な抽象化のタイミングを見極めることが重要です。</p>
      <h2>抽象化の3つの基準</h2>
      <p>カスタムフックを作成する前に、次の3つの問いを自分に投げかけてみてください。このロジックは本当に再利用されるか？テストの容易さは向上するか？コードの意図がより明確になるか？</p>
      <p>3つのうち2つ以上にYesと答えられるなら、カスタムフックの作成は正当化されるでしょう。</p>
    `,
  },
];
